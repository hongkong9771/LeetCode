class Solution:
    def twoEggDrop(self, n: int) -> int:
        """
        可以将楼层划分成多个区间，第一个玻璃球A1用来确定破碎极限属于哪个区间，第二个玻璃球A2按顺序遍历该区间找到破碎极限。那么问题就转换为怎么划分区间满足最坏情况下扔玻璃球次数最少。
        A1需要从第一个区间开始遍历到最后一个区间。如果按等大小的方式划分区间，那么A2的遍历次数固定。那么最坏的情况是破碎极限出现在最后一个区间，此时A1遍历的次数最多。为了使最坏情况下A1和A2总共遍历的次数比较少，那么后面的区间大小要比前面的区间宽度更小。具体来说，A1每多遍历一次，A2要少遍历一次，才使得破碎极限无论在哪个区间，总共遍历的次数一样。
设第一个区间大小为X，那么第二个区间的大小为X-1，以此类推。那么X + (X-1) + (X-2) + … + 1 = 100，得到X (X + 1) / 2 = 100，即X = 14。

    假设对于 n 层楼计算并返回要确定 f 确切的值的最小操作次数为 M ， 我们可以有以下结论：
    第一次操作必然选择在 x ≤ M 层，这里使用反证法：当 x > M ，如果第一次操作后鸡蛋破碎，则转入第2枚鸡蛋任务，需要 x - 1 次操作逐层验证，总操作次数为 1 + (x - 1) = x > M ，违背总操作次数为 M 的假设
第 k 次操作第1枚鸡蛋的覆盖层数必须小于等于 M - k + 1 ，原因同 1
综合(1, 2)的限制，可以得出 M 次操作可以覆盖的最大楼层数量为 Sum = M + (M - 1) + (M - 2) + ... + 1 = (M + 1) * M / 2
得到关系：(M + 1) * M / 2 ≥ n，则满足条件的 M 最小值即为最小操作次数，用数学方法求解即可：
        """
        i = 1
        res = 0
        while res < n:
            res += i
            i += 1
        return i - 1