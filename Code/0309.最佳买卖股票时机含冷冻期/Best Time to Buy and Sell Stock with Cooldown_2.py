class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        """
        dp[i][0]表示第i天持有股票的现金，dp[i][1]表示第i天不持有股票的现金。假设最开始的现金为0元
        则dp[i][0]可以分成两种情况：
        1）当天并未买入股票，则可能是由前一天购买的股票，所以dp[i][0] = dp[i-1][0]
        2）当天买入股票，所以dp[i][0] = dp[i-1] - price[i]   （此处是与LC121题的不同之处）
        dp[i][1]可以分成两种情况：
        1）当天并未卖出股票，则可能是前一天卖出的股票，所以dp[i][1] = dp[i-1][1]
        2）当天卖出股票，所以dp[i][1] = dp[i-1][0] + price[i]

        对于包含冷冻期而言，一共有以下四种状态：
        dp[i][0]：当前处于买入状态
        dp[i][1]：当前处于卖出状态，且已经过了冷冻期(前两天卖出的股票)
        dp[i][2]：当天卖出股票
        dp[i][3]：当前处于冷冻期（冷冻期只有一天，就是今天）
        对于dp[i][0]而言：
        1）当天并未买入股票，则可能是由前一天买入的，所以dp[i][0] = dp[i-1][0]
        2）当天买入股票，所以dp[i][0] = dp[i-1][1] - price[i] 或者 dp[i-1][3] - price[i]
        对于dp[i][1]而言：
        1）当天并未卖出股票，则可能是前两天卖出的股票，所以dp[i][1] = dp[i-1][1]
        2）前一天刚处于冷冻期，所以dp[i][1] = dp[i-1][3]
        对于dp[i][2]而言：
        1）当天卖出的股票，所以dp[i][2] = dp[i-1][0] + price[i]
        对于dp[i][3]而言：
        1）前一天刚卖出股票，所以dp[i][3] = dp[i-1][2]

        由于每一个状态都只与前一天的状态有关，所以可以采用压缩空间的做法
        """

        l = len(prices)
        if l == 0:
            return 0
        
        dp = [[0] * 4 for _ in range(2)]
        # dp = [[0] * 4] * 2  此种方法得到数组，在下面的初始化中会出现问题，感觉有点奇怪，以后注意使用上面的矩阵赋值方法

        # 动态数组初始化
        dp[0][0] = -prices[0]
        
        # 动态传递过程
        for i in range(1, l):
            dp[i%2][0] = max(dp[(i-1)%2][0], max(dp[(i-1)%2][1], dp[(i-1)%2][3]) - prices[i])
            dp[i%2][1] = max(dp[(i-1)%2][1], dp[(i-1)%2][3])
            dp[i%2][2] = dp[(i-1)%2][0] + prices[i]
            dp[i%2][3] = dp[(i-1)%2][2]
        return max(dp[(l-1)%2][1], dp[(l-1)%2][2], dp[(l-1)%2][3])
